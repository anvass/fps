<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        body {
            position: relative;
            background: gray;
            margin: 0;
            padding: 0;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            border: 1px solid rgba(0, 0, 0, 0.5);
            /*background: white;*/
        }
    </style>
</head>
<body>
<script type="module">
     class Bitmap {
        constructor(width, height, scale = 1) {
            this.width = width
            this.height = height

            this.scale = scale
            this.scaledWidth = Math.round(width * scale)
            this.scaledHeight = Math.round(height * scale)

            this.data = new Float64Array(this.scaledWidth * this.scaledHeight)
        }

        clean() {
            this.data.fill(0)
        }

        set(x, y, val) {
            const startY = Math.floor(y * this.scale)
            const endY = Math.ceil((y + 1) * this.scale)
            const startX = Math.floor(x * this.scale)
            const endX = Math.ceil((x + 1) * this.scale)

            for (let sy = startY; sy < endY; sy++) {
                for (let sx = startX; sx < endX; sx++) {
                    this.data[sy * this.scaledWidth + sx] = Math.min(1, Math.max(0, val))
                }
            }
        }

        get(x, y) {
            const sx = Math.floor(x * this.scale)
            const sy = Math.floor(y * this.scale)
            const idx = sy * this.scaledWidth + sx
            return idx >= 0 && idx < this.data.length ? this.data[idx] : 0
        }

        setScaled(x, y, val) {
            const idx = Math.floor(y * this.scaledWidth + x);
            if (idx >= 0 && idx < this.data.length) {
                this.data[idx] = Math.min(1, Math.max(0, val))
            }
        }

        getScaled(x, y) {
            const idx = Math.floor(y * this.scaledWidth + x)
            return idx >= 0 && idx < this.data.length ? this.data[idx] : 0
        }


        getInPercents(px, py) {
            const x = Math.floor(px * this.scaledWidth)
            const y = Math.floor(py * this.scaledHeight)
            const idx = y * this.scaledWidth + x
            return idx >= 0 && idx < this.data.length ? this.data[idx] : 0
        }
    }


    const renderers = {
         1: (pos) => {
             return [
                 pos.x, pos.y, pos.x + 1, pos.y,
                 pos.x, pos.y, pos.x, pos.y + 1,
                 pos.x + 1, pos.y + 1, pos.x, pos.y + 1,
                 pos.x + 1, pos.y + 1, pos.x + 1, pos.y,
             ];
         },
        2: (pos, doorWidth, doorOffset) => {
            const halfDoorWidth = doorWidth / 2;
            return [
                // top
                pos.x, pos.y + 0.5 - halfDoorWidth, pos.x + 1 - doorOffset, pos.y + 0.5 - halfDoorWidth,
                // bottom
                pos.x, pos.y + 0.5 + halfDoorWidth, pos.x + 1 - doorOffset, pos.y + 0.5 + halfDoorWidth,
                // left
                pos.x, pos.y + 0.5 - halfDoorWidth, pos.x, pos.y + 0.5 + halfDoorWidth,
                // right
                pos.x + 1 - doorOffset, pos.y + 0.5 - halfDoorWidth, pos.x + 1 - doorOffset, pos.y + 0.5 + halfDoorWidth,
            ];
        }
    }


     export function buildTileMapEdgesSimple(world, sx, sy, width, height, fBlockWidth) {
         /** @type {{sx: number, sy: number, ex: number, ey: number}[]} */
         const vecEdges = []

         for (let x = 0; x < width; x++) {
             for (let y = 0; y < height; y++) {

                 const cellIndex = (y + sy) * width + (x + sx);

                 if (!world[cellIndex]) continue;

                 vecEdges.push(
                    // top
                    {
                        sx: (x + sx) * fBlockWidth,
                        sy: (y + sy) * fBlockWidth,
                        ex: (x + sx + 1) * fBlockWidth,
                        ey: (y + sy) * fBlockWidth
                    },
                    // bottom
                    {
                        sx: (x + sx) * fBlockWidth,
                        sy: (y + sy + 1) * fBlockWidth,
                        ex: (x + sx + 1) * fBlockWidth,
                        ey: (y + sy + 1) * fBlockWidth
                    },
                    // left
                    {
                        sx: (x + sx) * fBlockWidth,
                        sy: (y + sy) * fBlockWidth,
                        ex: (x + sx) * fBlockWidth,
                        ey: (y + sy + 1) * fBlockWidth
                    },
                    // right
                    {
                        sx: (x + sx + 1) * fBlockWidth,
                        sy: (y + sy) * fBlockWidth,
                        ex: (x + sx + 1) * fBlockWidth,
                        ey: (y + sy + 1) * fBlockWidth
                    }
                 );
             }
         }
         return vecEdges;
     }

     export function buildTileMapEdges(world, sx, sy, width, height, fBlockWidth, padding = 0) {
         const worldEdges = world.map(() => ({
             edge_id: [0, 0, 0, 0],
             edge_exist: [false, false, false, false]
         }))
         const vecEdges = []

         for (let x = 0; x < width; x++) {
             for (let y = 0; y < height; y++) {
                 for (let j = 0; j < 4; j++) {
                     worldEdges[(y + sy) * width + (x + sx)].edge_exist[j] = false
                     worldEdges[(y + sy) * width + (x + sx)].edge_id[j] = 0
                 }
             }
         }

         vecEdges.push(
             // top
             {
                 sx: -padding,
                 sy: sy - padding,
                 ex: width * fBlockWidth + padding,
                 ey: sy - padding
             }, // bottom
             {
                 sx: -padding,
                 sy: height * fBlockWidth + padding,
                 ex: width * fBlockWidth + padding,
                 ey: height * fBlockWidth + padding
             }, // left
             {
                 sx: -padding,
                 sy: -padding,
                 ex: -padding,
                 ey: height * fBlockWidth + padding
             }, // right
             {
                 sx: width * fBlockWidth + padding,
                 sy: -padding,
                 ex: width * fBlockWidth + padding,
                 ey: height * fBlockWidth + padding
             }
         )

         for (let x = 0; x < width; x++) {
             for (let y = 0; y < height; y++) {
                 const i = (y + sy) * width + (x + sx) // This
                 const n = (y + sy - 1) * width + (x + sx) // Northern Neighbour
                 const s = (y + sy + 1) * width + (x + sx) // Southern Neighbour
                 const w = (y + sy) * width + (x + sx - 1) // Western Neighbour
                 const e = (y + sy) * width + (x + sx + 1) // Eastern Neighbour

                 const ne = (y + sy - 1) * width + (x + sx + 1) // Northern Eastern Neighbour
                 const nw = (y + sy - 1) * width + (x + sx - 1) // Northern Western Neighbour
                 const se = (y + sy + 1) * width + (x + sx + 1) // Southern Eastern Neighbour
                 const sw = (y + sy + 1) * width + (x + sx - 1) // Southern Western Neighbour

                 if (world[i]) {
                     if (!world[w]) {
                         if (worldEdges[n]?.edge_exist[WEST]) {
                             vecEdges[worldEdges[n].edge_id[WEST]].ey += fBlockWidth
                             worldEdges[i].edge_id[WEST] = worldEdges[n].edge_id[
                                 WEST
                                 ]
                             worldEdges[i].edge_exist[WEST] = true
                         } else {
                             const edge = {
                                 sx: (sx + x) * fBlockWidth + padding,
                                 sy: (sy + y) * fBlockWidth + padding,
                                 ex: (sx + x) * fBlockWidth + padding,
                                 ey: (sy + y) * fBlockWidth + fBlockWidth - padding
                             }

                             const edge_id = vecEdges.length
                             vecEdges.push(edge)

                             worldEdges[i].edge_id[WEST] = edge_id
                             worldEdges[i].edge_exist[WEST] = true
                         }

                         const edge = vecEdges[worldEdges[i].edge_id[WEST]]
                         if (world[sw] && (world[s] || world[w])) {
                             edge.ey += padding * 2
                         }
                         if (world[nw] && (world[n] || world[w])) {
                             edge.sy -= padding * 2
                         }
                     }

                     if (!world[e]) {
                         if (worldEdges[n]?.edge_exist[EAST]) {
                             vecEdges[worldEdges[n].edge_id[EAST]].ey += fBlockWidth
                             worldEdges[i].edge_id[EAST] = worldEdges[n].edge_id[
                                 EAST
                                 ]
                             worldEdges[i].edge_exist[EAST] = true
                         } else {
                             const edge = {
                                 sx: (sx + x + 1) * fBlockWidth - padding,
                                 sy: (sy + y) * fBlockWidth + padding,
                                 ex: (sx + x + 1) * fBlockWidth - padding,
                                 ey: (sy + y) * fBlockWidth + fBlockWidth - padding
                             }

                             const edge_id = vecEdges.length
                             vecEdges.push(edge)

                             worldEdges[i].edge_id[EAST] = edge_id
                             worldEdges[i].edge_exist[EAST] = true
                         }

                         const edge = vecEdges[worldEdges[i].edge_id[EAST]]
                         if (world[ne] && (world[n] || world[e])) {
                             edge.sy -= padding * 2
                         }
                         if (world[se] && (world[s] || world[w])) {
                             edge.ey += padding * 2
                         }
                     }

                     if (!world[n]) {
                         if (worldEdges[w]?.edge_exist[NORTH]) {
                             vecEdges[worldEdges[w].edge_id[NORTH]].ex += fBlockWidth
                             worldEdges[i].edge_id[NORTH] = worldEdges[w].edge_id[
                                 NORTH
                                 ]
                             worldEdges[i].edge_exist[NORTH] = true
                         } else {
                             const edge = {
                                 sx: (sx + x) * fBlockWidth + padding,
                                 sy: (sy + y) * fBlockWidth + padding,
                                 ex: (sx + x) * fBlockWidth + fBlockWidth - padding,
                                 ey: (sy + y) * fBlockWidth + padding
                             }

                             const edge_id = vecEdges.length
                             vecEdges.push(edge)

                             worldEdges[i].edge_id[NORTH] = edge_id
                             worldEdges[i].edge_exist[NORTH] = true
                         }

                         const edge = vecEdges[worldEdges[i].edge_id[NORTH]]
                         if (world[ne] && (world[n] || world[e])) {
                             edge.ex += padding * 2
                         }
                         if (world[nw] && (world[n] || world[w])) {
                             edge.sx -= padding * 2
                         }
                     }

                     if (!world[s]) {
                         if (worldEdges[w]?.edge_exist[SOUTH]) {
                             vecEdges[worldEdges[w].edge_id[SOUTH]].ex += fBlockWidth
                             worldEdges[i].edge_id[SOUTH] = worldEdges[w].edge_id[
                                 SOUTH
                                 ]
                             worldEdges[i].edge_exist[SOUTH] = true
                         } else {
                             const edge = {
                                 sx: (sx + x) * fBlockWidth + padding,
                                 sy: (sy + y + 1) * fBlockWidth - padding,
                                 ex: (sx + x) * fBlockWidth + fBlockWidth - padding,
                                 ey: (sy + y + 1) * fBlockWidth - padding
                             }

                             const edge_id = vecEdges.length
                             vecEdges.push(edge)

                             worldEdges[i].edge_id[SOUTH] = edge_id
                             worldEdges[i].edge_exist[SOUTH] = true
                         }
                     }

                     const edge = vecEdges[worldEdges[i].edge_id[SOUTH]]
                     if (world[sw] && (world[s] || world[w])) {
                         edge.sx -= padding * 2
                     }
                     if (world[se] && (world[s] || world[e])) {
                         edge.ex += padding * 2
                     }
                 }
             }
         }
         return vecEdges;
     }

     const NORTH = 0, SOUTH = 1, EAST = 2, WEST = 3;

     const eps = 0.0001;

     class LightCasting2D {
         constructor(radius, quality = 1, bendOffset = 0) {
             this.radius = radius

             this.vecVisibilityPolygonPoints = [];

             /** @type {Bitmap} */
             this.lightMap = new Bitmap(radius * 2, radius * 2, quality)

             this.emitterPosition = { x: 0, y: 0 }
             this.boundingBox = { ex: 0, ey: 0, sx: 0, sy: 0 }
             this.bendOffset = bendOffset;
         }

         // addTileMapToPolyMap(world, sx, sy, width, height, fBlockWidth, padding = 0) {
         //     this.world = world;
         //     // this.vecEdges = buildTileMapEdges(world, sx, sy, width, height, fBlockWidth, padding)
         //     this.vecEdges = buildTileMapEdgesSimple(world, sx, sy, width, height, fBlockWidth, padding)
         //
         //     this.vecEdges.push(
         //         // top
         //         {
         //             sx: -padding,
         //             sy: sy - padding,
         //             ex: width * fBlockWidth + padding,
         //             ey: sy - padding
         //         }, // bottom
         //         {
         //             sx: -padding,
         //             sy: height * fBlockWidth + padding,
         //             ex: width * fBlockWidth + padding,
         //             ey: height * fBlockWidth + padding
         //         }, // left
         //         {
         //             sx: -padding,
         //             sy: -padding,
         //             ex: -padding,
         //             ey: height * fBlockWidth + padding
         //         }, // right
         //         {
         //             sx: width * fBlockWidth + padding,
         //             sy: -padding,
         //             ex: width * fBlockWidth + padding,
         //             ey: height * fBlockWidth + padding
         //         }
         //     )
         // }

         calculateVisibilityPolygon(ox, oy) {
             this.emitterPosition = { x: ox, y: oy }

             this.boundingBox = {
                 sx: this.emitterPosition.x - this.radius,
                 sy: this.emitterPosition.y - this.radius,
                 ex: this.emitterPosition.x + this.radius,
                 ey: this.emitterPosition.y + this.radius
             }

             this.vecVisibilityPolygonPoints = []

             const countRadialRays = 20;
             const pointToLineDistance = 0.01;
             const joinPointsDistance = 0.01;

             for (let i = 0; i <= countRadialRays; i++) {
                 const ang = -Math.PI + (i * Math.PI * 2) / countRadialRays
                 const current = this.castLightRay(ox, oy, ang, this.radius)

                 const prev2 = this.vecVisibilityPolygonPoints[
                 this.vecVisibilityPolygonPoints.length - 2
                     ]
                 const prev = this.vecVisibilityPolygonPoints[
                 this.vecVisibilityPolygonPoints.length - 1
                     ]

                 if (
                     prev2 &&
                     prev &&
                     getDistanceFrom2DPointToLine(
                         current.x,
                         current.y,
                         prev2.x,
                         prev2.y,
                         prev.x,
                         prev.y
                     ) <= pointToLineDistance
                 ) {
                     prev.x = current.x
                     prev.y = current.y
                 } else {
                     this.vecVisibilityPolygonPoints.push(current)
                 }
             }

             for (let i = 0; i < this.vecEdges.length - 1; i += 4) {
                 const sx = this.vecEdges[i];
                 const sy = this.vecEdges[i + 1];
                 const ex = this.vecEdges[i + 2];
                 const ey = this.vecEdges[i + 3];

                 const bothOfEdgePointsOutOfDistance =
                     distToSegment(ox, oy, sx, sy, ex, ey) > this.radius
                 if (bothOfEdgePointsOutOfDistance) continue

                 for (let i = 0; i < 2; i++) {
                     const rdx = (i === 0 ? sx : ex) - ox
                     const rdy = (i === 0 ? sy : ey) - oy

                     let ang = 0
                     const base_ang = Math.atan2(rdy, rdx)

                     for (let j = 0; j < 3; j++) {
                         const delta = 0.001
                         if (j === 0) ang = base_ang - delta
                         if (j === 1) ang = base_ang
                         if (j === 2) ang = base_ang + delta

                         const vec = this.castLightRay(ox, oy, ang, this.radius)
                         this.vecVisibilityPolygonPoints.push(vec)
                     }
                 }
             }


             this.vecVisibilityPolygonPoints.sort((p1, p2) => (p1.ang < p2.ang ? -1 : 1))


             const uniqVecVisibilityPolygonPoints = []
             for (let i = 0; i < this.vecVisibilityPolygonPoints.length - 1; i++) {
                 const prev = this.vecVisibilityPolygonPoints[i - 1]
                 const current = this.vecVisibilityPolygonPoints[i]
                 let next = this.vecVisibilityPolygonPoints[i + 1]

                 uniqVecVisibilityPolygonPoints.push(current)

                 let isClosePoint =
                     Math.abs(current.x - next.x) < joinPointsDistance &&
                     Math.abs(current.y - next.y) < joinPointsDistance
                 while (next && isClosePoint) {
                     i++
                     next = this.vecVisibilityPolygonPoints[i + 1]
                     isClosePoint =
                         next &&
                         Math.abs(current.x - next.x) < joinPointsDistance &&
                         Math.abs(current.y - next.y) < joinPointsDistance
                 }


                 let nextPointOnCurrentLine =
                     prev &&
                     current &&
                     next &&
                     getDistanceFrom2DPointToLine(
                         next.x,
                         next.y,
                         prev.x,
                         prev.y,
                         current.x,
                         current.y
                     ) <= pointToLineDistance
                 while (nextPointOnCurrentLine) {
                     current.x = next.x
                     current.y = next.y
                     i++
                     next = this.vecVisibilityPolygonPoints[i + 1]
                     nextPointOnCurrentLine =
                         prev &&
                         current &&
                         next &&
                         getDistanceFrom2DPointToLine(
                             next.x,
                             next.y,
                             prev.x,
                             prev.y,
                             current.x,
                             current.y
                         ) <= pointToLineDistance
                 }
             }
             this.vecVisibilityPolygonPoints = uniqVecVisibilityPolygonPoints

             // add last segment
             this.vecVisibilityPolygonPoints.push({
                 x: this.vecVisibilityPolygonPoints[0].x,
                 y: this.vecVisibilityPolygonPoints[0].y,
                 ang: this.vecVisibilityPolygonPoints[0].ang + Math.PI * 2
             })

             this.fillLightMap(ox, oy);
         }

         fillLightMap(ox, oy) {
             this.lightMap.clean()
             const mapStartX = ox - this.radius
             const mapStartY = oy - this.radius

             const radiusInLightMap = this.lightMap.scaledWidth / 2

             for (let i = 0; i < this.vecVisibilityPolygonPoints.length - 1; i++) {
                 const current = this.vecVisibilityPolygonPoints[i]
                 const next = this.vecVisibilityPolygonPoints[i + 1]

                 const minX = Math.floor(
                     (Math.min(ox, current.x, next.x) - mapStartX) * this.lightMap.scale
                 )
                 const minY = Math.floor(
                     (Math.min(oy, current.y, next.y) - mapStartY) * this.lightMap.scale
                 )
                 const maxX = Math.floor(
                     (Math.max(ox, current.x, next.x) - mapStartX) * this.lightMap.scale - eps
                 )
                 const maxY = Math.floor(
                     (Math.max(oy, current.y, next.y) - mapStartY) * this.lightMap.scale - eps
                 )

                 for (let x = minX; x <= maxX; x++) {
                     for (let y = minY; y <= maxY; y++) {
                         if (this.lightMap.getScaled(x, y) > 0) continue;

                         const isInTriangle = is2DPointInTriangle(
                             x + 0.5,
                             y + 0.5,
                             radiusInLightMap,
                             radiusInLightMap,
                             (current.x - mapStartX) * this.lightMap.scale,
                             (current.y - mapStartY) * this.lightMap.scale,
                             (next.x - mapStartX) * this.lightMap.scale,
                             (next.y - mapStartY) * this.lightMap.scale
                         );
                         if (isInTriangle) {
                             this.lightMap.setScaled(
                                 x,
                                 y,
                                 1 -
                                 getMagnitude(x + 0.5, y + 0.5, radiusInLightMap, radiusInLightMap) /
                                 ( radiusInLightMap + 1 )
                             )
                         }

                         const isInSquare = isSquareIntersectTriangle(
                             x,
                             y,
                             1,
                             radiusInLightMap,
                             radiusInLightMap,
                             (current.x - mapStartX) * this.lightMap.scale,
                             (current.y - mapStartY) * this.lightMap.scale,
                             (next.x - mapStartX) * this.lightMap.scale,
                             (next.y - mapStartY) * this.lightMap.scale
                         );

                         if (isInSquare) {
                             this.lightMap.setScaled(
                                 x,
                                 y,
                                 1 - (getMagnitude(x + 0.5, y + 0.5, radiusInLightMap, radiusInLightMap) / ( radiusInLightMap + 1 ))
                             );
                         }

                     }
                 }
             }
         }

         castLightRay(ox, oy, ang, distance) {
             const rdx = distance * Math.cos(ang)
             const rdy = distance * Math.sin(ang)

             const closestPoint = {
                 ang: ang,
                 x: ox + rdx,
                 y: oy + rdy,
                 magnitude: distance
             }
             const pointAfterClosest = {
                 ang: ang,
                 x: ox + rdx,
                 y: oy + rdy,
                 magnitude: distance
             }

             for (let i = 0; i < this.vecEdges.length - 1; i += 4) {
                 const sx = this.vecEdges[i];
                 const sy = this.vecEdges[i + 1];
                 const ex = this.vecEdges[i + 2];
                 const ey = this.vecEdges[i + 3];

                 const bothOfEdgePointsOutOfDistance =
                     distToSegment(ox, oy, sx, sy, ex, ey) > distance
                 if (bothOfEdgePointsOutOfDistance) continue

                 const intersection = getLineIntersectPoint(
                     sx,
                     sy,
                     ex,
                     ey,
                     ox,
                     oy,
                     ox + rdx,
                     oy + rdy
                 )
                 if (!intersection) continue

                 const magnitude = getMagnitude(intersection.x, intersection.y, ox, oy)
                 if (magnitude < closestPoint.magnitude) {
                     pointAfterClosest.magnitude = closestPoint.magnitude
                     pointAfterClosest.ang = closestPoint.ang
                     pointAfterClosest.x = closestPoint.x
                     pointAfterClosest.y = closestPoint.y

                     closestPoint.magnitude = magnitude
                     closestPoint.ang = Math.atan2(intersection.y - oy, intersection.x - ox)
                     closestPoint.x = intersection.x
                     closestPoint.y = intersection.y
                 } else if (magnitude < pointAfterClosest.magnitude) {
                     pointAfterClosest.magnitude = magnitude
                     pointAfterClosest.ang = Math.atan2(
                         intersection.y - oy,
                         intersection.x - ox
                     )
                     pointAfterClosest.x = intersection.x
                     pointAfterClosest.y = intersection.y
                 }

             }

             const offsetPart = this.bendOffset;
             return {
                 ang: closestPoint.ang,
                 x: (pointAfterClosest.x - closestPoint.x) * offsetPart + closestPoint.x,
                 y: (pointAfterClosest.y - closestPoint.y) * offsetPart + closestPoint.y,
                 magnitude:
                     (pointAfterClosest.magnitude - closestPoint.magnitude) * offsetPart
             }
         }

         checkPointInBoundingBox(x, y) {
             return (
                 (x - eps) < this.boundingBox.sx ||
                 (x + eps) > this.boundingBox.ex ||
                 (y - eps) < this.boundingBox.sy ||
                 (y + eps) > this.boundingBox.ey
             )
         }

         getLightLevelInPoint(x, y) {
             if (this.checkPointInBoundingBox(x, y)) return 0
             return this.lightMap.getInPercents(
                 (x - this.boundingBox.sx) / this.lightMap.width,
                 (y - this.boundingBox.sy) / this.lightMap.height
             )
         }
     }

     console.log('LightCasting2D', LightCasting2D);

     function getMagnitude(sx, sy, ex, ey) {
        return Math.sqrt(Math.pow(sx - ex, 2) + Math.pow(sy - ey, 2));
    }

     function getLineIntersectPoint(x1, y1, x2, y2, x3, y3, x4, y4) {
         if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) return false;
         const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))
         if (denominator === 0) return false;
         let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
         let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator
         if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return false;
         return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
     }

     function isLinesHasIntersections(x1, y1, x2, y2, x3, y3, x4, y4) {
         if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) return false;
         const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))
         if (denominator === 0) return false;
         let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
         let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator
         return !(ua < 0 || ua > 1 || ub < 0 || ub > 1);
     }

    function dist2(x, y, x2, y2) {
        return Math.pow(x - x2, 2) + Math.pow(y - y2, 2)
    }

    function distToSegment(x, y, sx, sy, ex, ey) {
        const l2 = dist2(sx, sy, ex, ey);
        if (l2 === 0) return getMagnitude(x, y, sx, sy);
        let t = ((x - sx) * (ex - sx) + (y - sy) * (ey - sy)) / l2;
        t = Math.max(0, Math.min(1, t));
        return getMagnitude(x, y, sx + t * (ex - sx), sy + t * (ey - sy));
    }

    function getDistanceFrom2DPointToLine(pointX, pointY, pointOnLineX, pointOnLineY, anotherPointOnLineX, anotherPointOnLineY) {
        const A = anotherPointOnLineY - pointOnLineY;
        const B = pointOnLineX - anotherPointOnLineX;
        const C = anotherPointOnLineX * pointOnLineY - pointOnLineX * anotherPointOnLineY;
        return Math.abs(A * pointX + B * pointY + C) / Math.sqrt(A * A + B * B);
    }

    function is2DPointInTriangle(pointX, pointY, triangleP1x, triangleP1y, triangleP2x, triangleP2y, triangleP3x, triangleP3y) {
        const a = (triangleP1x - pointX) * (triangleP2y - triangleP1y) - (triangleP2x - triangleP1x) * (triangleP1y - pointY);
        const b = (triangleP2x - pointX) * (triangleP3y - triangleP2y) - (triangleP3x - triangleP2x) * (triangleP2y - pointY);
        const c = (triangleP3x - pointX) * (triangleP1y - triangleP3y) - (triangleP1x - triangleP3x) * (triangleP3y - pointY);
        return  (a >= 0 && b >= 0 && c >= 0) || (a <= 0 && b <= 0 && c <= 0);
    }

     function isSquareIntersectTriangle(sx, sy, sSize, t1x, t1y, t2x, t2y, t3x, t3y) {
         return (
             isLinesHasIntersections(sx, sy, sx + sSize, sy, t1x, t1y, t2x, t2y) ||
             isLinesHasIntersections(sx + sSize, sy, sx + sSize, sy + sSize, t2x, t2y, t3x, t3y) ||
             isLinesHasIntersections(sx + sSize, sy + sSize, sx, sy + sSize, t3x, t3y, t1x, t1y) ||
             isLinesHasIntersections(sx, sy + sSize, sx, sy, t1x, t1y, t2x, t2y) ||
             isLinesHasIntersections(sx, sy, sx + sSize, sy, t2x, t2y, t3x, t3y) ||
             isLinesHasIntersections(sx, sy, sx + sSize, sy + sSize, t3x, t3y, t1x, t1y) ||
             isLinesHasIntersections(sx + sSize, sy, sx + sSize, sy + sSize, t1x, t1y, t2x, t2y) ||
             isLinesHasIntersections(sx + sSize, sy + sSize, sx, sy + sSize, t2x, t2y, t3x, t3y) ||
             isLinesHasIntersections(sx + sSize, sy + sSize, sx, sy, t3x, t3y, t1x, t1y)
         );
     }

     ///// demo


    let _mouseX = 0;
    let _mouseY = 0;
    let _mouseDown = undefined;
    let _mouseReleased = false;
    let _mouseHeld = false;
    document.addEventListener('mousedown', (event) => {
        _mouseReleased = false;
        _mouseDown = event.button;
        _mouseHeld = true;
    });
    function mouseX() {
        return _mouseX;
    }
    function mouseY() {
        return _mouseY;
    }
    function mouseButton() {
        if (_mouseDown === undefined) return _mouseDown;
        return _mouseDown === 0 ? 'left' : 'right';
    }
    function mouseReleased() {
        return _mouseReleased;
    }
    function mouseHeld() {
        return _mouseHeld;
    }
    document.addEventListener('mouseup', () => {
        _mouseReleased = true;
    });
    document.addEventListener('mousemove', (e) => {
        _mouseX = e.clientX - canvas.offsetLeft;
        _mouseY = e.clientY - canvas.offsetTop;
        if (mouseButton()) {
            _mouseHeld = true;
        }
    });

    const nWorldWidth = 6;
    const nWorldHeight = 6;
    const cellSize = 150;

    const lightRadius = 4;
    const lightScale = 20;
    const lightBend = 0.02;

    let canvas, buffLightRay, buffLightTex;

    const canvasWidth = nWorldWidth * cellSize;
    const canvasHeight = nWorldHeight * cellSize;


    class Main {
        constructor() {
            this.world = [
                1, 0, 0, 0, 1, 0, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 1, 2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 2, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0,
                0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            ]
            this.shadowCaster = new LightCasting2D(lightRadius, lightScale, lightBend);

            window.lm = this.shadowCaster.lightMap;

            canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            window.ctx = canvas.getContext('2d');

            buffLightTex = document.createElement('canvas');
            document.body.appendChild(buffLightTex);
            buffLightTex.width = canvasWidth;
            buffLightTex.height = canvasHeight;
            window.ctx2 = buffLightTex.getContext('2d');

            buffLightRay = document.createElement('canvas');
            document.body.appendChild(buffLightRay);
            buffLightRay.width = canvasWidth;
            buffLightRay.height = canvasHeight;
            window.ctx3 = buffLightRay.getContext('2d');
        }

        update() {
            let fSourceX = mouseX();
            let fSourceY = mouseY();

            if (mouseButton() === 'left' && mouseReleased()) {
                let i = ((Math.floor(fSourceY / cellSize)) * nWorldWidth + Math.floor(fSourceX / cellSize));
                this.world[i] = !this.world[i];
            }

            if (mouseButton() === 'right' && mouseHeld()) {
                this.shadowCaster.calculateVisibilityPolygon(fSourceX / cellSize, fSourceY / cellSize);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // draw grid
            for (let x = 0; x < nWorldWidth; x++) {
                for (let y = 0; y < nWorldHeight; y++) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.moveTo(x * cellSize, y * cellSize);
                    ctx.lineTo((x + 1) * cellSize, y * cellSize);
                    ctx.lineTo((x + 1) * cellSize, (y + 1) * cellSize);
                    ctx.lineTo(x * cellSize, (y + 1) * cellSize);
                    ctx.lineTo(x * cellSize, y * cellSize);
                    ctx.stroke();
                }
            }


            this.shadowCaster.vecEdges = [];
            for (let x = 0; x < nWorldWidth; x++) {
                for (let y = 0; y < nWorldHeight; y++) {
                    const worldElement = this.world[y * nWorldWidth + x];
                    if (!worldElement) continue;
                    const renderer = renderers[worldElement];
                    if (!renderer) continue;

                    let paths = renderer({x,y}, 0.5, 0.3);
                    this.shadowCaster.vecEdges.push(...paths);

                    if (paths.length < 8) return;
                    paths = paths.map(point => point * cellSize);
                    ctx.beginPath();
                    ctx.strokeStyle = 'black';
                    ctx.fillStyle = 'green';
                    ctx.moveTo(paths[0], paths[1]);
                    for (let i = 2; i < paths.length - 1; i += 2) {
                        ctx.lineTo(paths[i], paths[i + 1]);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }

            ctx.fillStyle = 'black';

            const renderCellSize = 3;
            for (let x = 0; x < canvasWidth; x = x + renderCellSize) {
                for (let y = 0; y < canvasHeight; y = y + renderCellSize) {
                    const isPointInLight = this.shadowCaster.getLightLevelInPoint(x / cellSize, y / cellSize);

                    const lightLevel = isPointInLight * 255;
                    ctx.beginPath();
                    ctx.fillStyle = `rgb(${lightLevel}, ${lightLevel}, ${lightLevel})`;
                    ctx.arc(x, y, 1, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            const vecVisibilityPolygonPoints = this.shadowCaster.vecVisibilityPolygonPoints;
            let nRaysCast = vecVisibilityPolygonPoints.length;

            ctx.font = "24px Arial";
            ctx.fillText(`Rays Cast: ${nRaysCast}`, 40, 30);
            ctx3.clearRect(0, 0, buffLightRay.width, buffLightRay.height);

            if (mouseButton() === 'right' && vecVisibilityPolygonPoints.length > 1) {
                ctx2.clearRect(0, 0, buffLightTex.width, buffLightTex.height);

                for (let i = 0; i < vecVisibilityPolygonPoints.length - 1; i++) {
                    ctx3.beginPath();
                    ctx3.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx3.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx3.moveTo(fSourceX, fSourceY);
                    ctx3.lineTo(vecVisibilityPolygonPoints[i].x * cellSize , vecVisibilityPolygonPoints[i].y * cellSize);
                    ctx3.lineTo(vecVisibilityPolygonPoints[i + 1].x * cellSize , vecVisibilityPolygonPoints[i + 1].y * cellSize);
                    ctx3.fill();
                    ctx3.stroke();
                }

                ctx3.beginPath();
                ctx3.moveTo(fSourceX, fSourceY);
                ctx3.lineTo(vecVisibilityPolygonPoints[vecVisibilityPolygonPoints.length - 1].x * cellSize, vecVisibilityPolygonPoints[vecVisibilityPolygonPoints.length - 1].y * cellSize);
                ctx3.lineTo(vecVisibilityPolygonPoints[0].x * cellSize, vecVisibilityPolygonPoints[0].y * cellSize);
                ctx3.fill();
            }

            // for (let i = 0; i < this.shadowCaster.vecEdges.length - 1; i += 4) {
            //     const sx = this.shadowCaster.vecEdges[i];
            //     const sy = this.shadowCaster.vecEdges[i + 1];
            //     const ex = this.shadowCaster.vecEdges[i + 2];
            //     const ey = this.shadowCaster.vecEdges[i + 3];
            //
            //     ctx.fillStyle = 'blue';
            //     ctx.beginPath();
            //     ctx.moveTo(sx * cellSize, sy * cellSize);
            //     ctx.lineTo(ex * cellSize, ey * cellSize);
            //     ctx.closePath();
            //     ctx.stroke();
            // }
        }
    }


    var main = new Main();

    const cb = dt => {
        main.update(dt);

        if (mouseButton() && mouseReleased()) {
            _mouseDown = undefined;
            _mouseHeld = false;
            _mouseReleased = false;
        }
        requestAnimationFrame(cb);
    };
    requestAnimationFrame(cb);

    ///////////////////////////////////////  demo 2


    const canvasPosition = { x: 800, y: 0 };
    var demoCanvas = document.createElement('canvas');
    document.body.appendChild(demoCanvas);
    demoCanvas.style = `position: absolute; top: ${canvasPosition.y}px; left: ${canvasPosition.x}px; background: white;`
    demoCanvas.width = 400;
    demoCanvas.height = 400;
    window.demoCtx = demoCanvas.getContext('2d');


    function setPixel(buffer, x, y, val) {
        if (val === undefined) return;
        if (val < 0) val = 0;
        if (val > 255) val = 255;

        const offset = 4 * (Math.floor(x) + Math.floor(y) * buffer.width);
        buffer.data[offset] = val;
        buffer.data[offset + 1] = val;
        buffer.data[offset + 2] = val;
        buffer.data[offset + 3] = 255;
    }

    function bitmapTest(mX, mY) {
        demoCtx.clearRect(0, 0, demoCanvas.width, demoCanvas.height);
        if (!window.lm) return;

        const buffer = demoCtx.createImageData(demoCanvas.width, demoCanvas.height);
        for (let y = 0; y < buffer.height; y++) {
            for (let x = 0; x < buffer.width; x++) {
                // setPixel(buffer, bm.width, x, y, bm.getInPercents(x / bm.width, y / bm.height));
                const pointExist = window.lm.getInPercents(x / buffer.width , y / buffer.height);
                setPixel(buffer, x, y, pointExist * 255);
            }
        }
        demoCtx.putImageData(buffer, 0, 0);
    }

    // return;
    const cb2 = () => {


        const mX = mouseX() - canvasPosition.x;
        const mY = mouseY() - canvasPosition.y;


        demoCtx.clearRect(0, 0, demoCanvas.width, demoCanvas.height);

        // inTriangleDetection(mX, mY);
        // angleTest(mX, mY);
        bitmapTest(mX, mY);


        if (mouseButton() && mouseReleased()) {
            _mouseDown = undefined;
            _mouseHeld = false;
            _mouseReleased = false;
        }
        requestAnimationFrame(cb2);
    };
    requestAnimationFrame(cb2);

</script>


</body>
</html>
