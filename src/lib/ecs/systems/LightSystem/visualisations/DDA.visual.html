<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DDA Visualization</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
        }
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
    </style>
</head>
<body>
<h1>DDA Raycasting Visualization</h1>
<p>Press WASD for move start ray point</p>

<label for="offset">Door offset:</label>
<input type="range" id="offset" min="0" max="100" value="80" />
<br />
<br />
<canvas id="canvas" width="700" height="400"></canvas>

<script>
    function getPerpWallDist({side, start, mapX, mapY,  stepX, stepY, rayDirX, rayDirY, tileSize, offset}) {
        return side === 0
            ? Math.abs((mapX * tileSize - start.x + offset + (1 - stepX) * tileSize / 2) / rayDirX)
            : Math.abs((mapY * tileSize - start.y + offset + (1 - stepY) * tileSize / 2) / rayDirY);
    }

    function castRay(start, rayAngleRad, map, maxRayLength, tileSize, doorWidth, doorOffset) {
        const rayDirX = Math.cos(rayAngleRad);
        const rayDirY = Math.sin(rayAngleRad);

        let mapX = Math.floor(start.x / tileSize);
        let mapY = Math.floor(start.y / tileSize);

        const deltaDistX = Math.abs(tileSize / rayDirX);
        const deltaDistY = Math.abs(tileSize / rayDirY);

        let stepX, stepY;
        let sideDistX, sideDistY;

        if (rayDirX < 0) {
            stepX = -1;
            sideDistX = Math.abs((start.x - mapX * tileSize) / rayDirX);
        } else {
            stepX = 1;
            sideDistX = Math.abs((( mapX + 1 ) * tileSize - start.x) / rayDirX);
        }

        if (rayDirY < 0) {
            stepY = -1;
            sideDistY = Math.abs((start.y - mapY * tileSize) / rayDirY);
        } else {
            stepY = 1;
            sideDistY = Math.abs((( mapY + 1 ) * tileSize - start.y) / rayDirY);
        }

        let isHitHappened = false;
        let side = 0;
        let offset = 0;


        const displayMap = {};

        while (!isHitHappened) {
            offset = 0;
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }

            if (map[mapY] && map[mapY][mapX] === 1) {
                isHitHappened = true;
                break;
            } else wallIf: if (map[mapY] && map[mapY][mapX] === 2) {

                const isHitWall = side === 1
                    ? sideDistY - (deltaDistY * ( 0.5 + doorWidth / tileSize / 2 )) > sideDistX
                    : sideDistX - (deltaDistX * ( 0.5 + doorWidth / tileSize / 2 )) > sideDistY;

                if (isHitWall) break wallIf;

                offset = side === 0
                    ? stepX * tileSize * ( 0.5 - doorWidth / tileSize / 2 )
                    : stepY * tileSize * ( 0.5 - doorWidth / tileSize / 2 );

                const perpWallDist = getPerpWallDist({
                    side,
                    mapX,
                    mapY,
                    tileSize,
                    start,
                    stepX,
                    rayDirX,
                    stepY,
                    rayDirY,
                    offset,
                });


                // check front hit closing/opening door
                const wallX = (start.x + rayDirX * perpWallDist) % tileSize;
                const wallY = (start.y + rayDirY * perpWallDist) % tileSize;
                const isHitDoor = side === 1
                    ? wallX > doorOffset
                    : wallY > doorOffset;

                if (isHitDoor) {
                    isHitHappened = true;
                    break wallIf;
                }

                // // check hit in side face
                if (side === 1) {
                    const closestDoorCornetPoint = {
                        x: mapX * tileSize + doorOffset,
                        y: mapY * tileSize + tileSize / 2 - doorWidth / 2
                    };
                    const angToClosestCorner = Math.atan2(closestDoorCornetPoint.y - start.y, closestDoorCornetPoint.x - start.x);
                    const angleToFaresCorner = Math.atan2(
                        closestDoorCornetPoint.y + doorWidth - start.y,
                        closestDoorCornetPoint.x - start.x
                    );
                    if ( rayAngleRad > angToClosestCorner  && rayAngleRad < angleToFaresCorner ) {
                        isHitHappened = true;

                        const angle = rayAngleRad < 0
                            ? rayAngleRad - Math.PI
                            : rayAngleRad;

                        const leg = (doorOffset - wallX);
                        const hypotenuse = leg / Math.cos(angle);
                        offset += Math.sqrt(( hypotenuse ** 2 ) - ( leg ** 2 )) * stepY;
                    }
                } else {
                    const closestDoorCornetPoint = {
                        x: mapX * tileSize + tileSize / 2 - doorWidth / 2,
                        y: mapY * tileSize + doorOffset,
                    };
                    const angToClosestCorner = Math.atan2(closestDoorCornetPoint.y - start.y, closestDoorCornetPoint.x - start.x);
                    const angleToFaresCorner = Math.atan2(
                        closestDoorCornetPoint.y - start.y,
                        closestDoorCornetPoint.x + doorWidth - start.x
                    );
                    if ( rayAngleRad > angleToFaresCorner && rayAngleRad < angToClosestCorner) {
                        isHitHappened = true;

                        const angle = rayAngleRad < (Math.PI / 2)
                            ? rayAngleRad
                            : rayAngleRad - Math.PI;

                        const leg = (doorOffset - wallY);
                        const hypotenuse = leg / Math.sin(angle);
                        offset += Math.sqrt(( hypotenuse ** 2 ) - ( leg ** 2 ))  * stepX;
                    }
                }
            }

            const rayLength = Math.min(sideDistX, sideDistY);
            if (rayLength > maxRayLength) break;
        }

        if (!isHitHappened) return null;

        const perpWallDist = getPerpWallDist({
            side,
            start,
            mapX,
            mapY,
            stepX,
            stepY,
            rayDirX,
            rayDirY,
            tileSize,
            offset,
        });
        const hitX =  start.x + rayDirX * perpWallDist;
        const hitY =  start.y + rayDirY * perpWallDist;

        return {
            mapX,
            mapY,
            hitX,
            hitY,
            perpWallDist,
            displayMap,
        }
    }


////  DEMO

    const tileSize = 100;
    const start = { x: 300, y: 400 }; // Starting position
    let target = { x: start.x + 100, y: start.y }; // Mouse-controlled target

    const doorWidth = 50;
    let doorOffset = 50;

    /** @type {HTMLInputElement} */
    const slider = document.getElementById('offset');
    slider.setAttribute('max', tileSize.toString());
    slider.value = doorOffset.toString();

    slider.addEventListener('input', () => {
        doorOffset = parseInt(slider.value);
    });

    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    document.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        target = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
        };
    });

    document.addEventListener('keydown', (e) => {
        const step = 10;
        if (e.key === 'w') start.y -= step;
        if (e.key === 's') start.y += step;
        if (e.key === 'a') start.x -= step;
        if (e.key === 'd') start.x += step;
    });


    const map = [
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 1, 2, 1, 1, 0, 0],
        [0, 0, 0, 0, 2, 0, 0],
        [0, 0, 0, 0, 1, 0, 0],
    ];



    function drawGrid() {
        for (let i = 0; i < map.length; i++) {
            for (let j = 0; j < map[i].length; j++) {
                ctx.strokeStyle = 'black';
                ctx.strokeRect(j * tileSize, i * tileSize, tileSize, tileSize);
                if (map[i][j] === 1) {
                    ctx.fillStyle = 'lightblue';
                    ctx.fillRect(j * tileSize, i * tileSize, tileSize, tileSize);
                }

                // door
                if (map[i][j] === 2) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';

                    if (map[i + 1][j] !== 0 && map[i - 1][j] !== 0) {
                        // vert
                        ctx.fillRect(
                            j * tileSize + tileSize / 2 - doorWidth / 2,
                            i * tileSize + doorOffset,
                            doorWidth,
                            tileSize
                        );
                    } else {
                        // horiz
                        ctx.fillRect(
                            j * tileSize + doorOffset,
                            i * tileSize + tileSize / 2 - doorWidth / 2,
                            tileSize,
                            doorWidth
                        );
                    }
                }
            }
        }
    }

    function drawRay() {
        const rayRad =  Math.atan2(target.y - start.y, target.x - start.x);

        const res = castRay(start, rayRad, map, 900, tileSize, doorWidth, doorOffset);

        ctx.fillStyle = 'black';
        ctx.fillText("Hit: " + Boolean(res).toString() , 10, 50);
        ctx.fillText("rayRad: " + rayRad.toString() , 10, 70);


        if (!res) {
            ctx.strokeStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
            return;
        }

        Object.entries(res.displayMap).forEach(([key, value], i) => {
            ctx.fillStyle = 'white';
            ctx.fillRect(10, 90 + i * 20, 300, 20);

            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.fillText(key + ": " + value.toString() , 10, 90 + i * 20);
            ctx.stroke();
        });

        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        ctx.arc(start.x, start.y, 5, 0, 2 * Math.PI);
        ctx.stroke();

        ctx.strokeStyle = 'blue';
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(res.hitX, res.hitY);
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(res.hitX, res.hitY, 5, 0, 2 * Math.PI);
        ctx.stroke();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawRay();
        requestAnimationFrame(draw);
    }

    draw();


</script>
</body>
</html>
